{"ast":null,"code":"// array in local storage for registered users\nlet users = JSON.parse(localStorage.getItem('users')) || [];\nexport function configureFakeBackend() {\n  let realFetch = window.fetch;\n  window.fetch = function (url, opts) {\n    return new Promise((resolve, reject) => {\n      // wrap in timeout to simulate server api call\n      setTimeout(() => {\n        // authenticate\n        if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n          // get parameters from post request\n          let params = JSON.parse(opts.body);\n\n          // find if any user matches login credentials\n          let filteredUsers = users.filter(user => {\n            return user.username === params.username && user.password === params.password;\n          });\n          if (filteredUsers.length) {\n            // if login details are valid return user details and fake jwt token\n            let user = filteredUsers[0];\n            let responseJson = {\n              id: user.id,\n              username: user.username,\n              firstName: user.firstName,\n              lastName: user.lastName,\n              token: 'fake-jwt-token'\n            };\n            resolve({\n              ok: true,\n              text: () => Promise.resolve(JSON.stringify(responseJson))\n            });\n          } else {\n            // else return error\n            reject('Username or password is incorrect');\n          }\n          return;\n        }\n\n        // get users\n        if (url.endsWith('/users') && opts.method === 'GET') {\n          // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n          if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n            resolve({\n              ok: true,\n              text: () => Promise.resolve(JSON.stringify(users))\n            });\n          } else {\n            // return 401 not authorised if token is null or invalid\n            reject('Unauthorised');\n          }\n          return;\n        }\n\n        // get user by id\n        if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\n          // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n          if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n            // find user by id in users array\n            let urlParts = url.split('/');\n            let id = parseInt(urlParts[urlParts.length - 1]);\n            let matchedUsers = users.filter(user => {\n              return user.id === id;\n            });\n            let user = matchedUsers.length ? matchedUsers[0] : null;\n\n            // respond 200 OK with user\n            resolve({\n              ok: true,\n              text: () => JSON.stringify(user)\n            });\n          } else {\n            // return 401 not authorised if token is null or invalid\n            reject('Unauthorised');\n          }\n          return;\n        }\n\n        // register user\n        if (url.endsWith('/users/register') && opts.method === 'POST') {\n          // get new user object from post body\n          let newUser = JSON.parse(opts.body);\n\n          // validation\n          let duplicateUser = users.filter(user => {\n            return user.username === newUser.username;\n          }).length;\n          if (duplicateUser) {\n            reject('Username \"' + newUser.username + '\" is already taken');\n            return;\n          }\n\n          // save new user\n          newUser.id = users.length ? Math.max(...users.map(user => user.id)) + 1 : 1;\n          users.push(newUser);\n          localStorage.setItem('users', JSON.stringify(users));\n\n          // respond 200 OK\n          resolve({\n            ok: true,\n            text: () => Promise.resolve()\n          });\n          return;\n        }\n\n        // delete user\n        if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\n          // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n          if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n            // find user by id in users array\n            let urlParts = url.split('/');\n            let id = parseInt(urlParts[urlParts.length - 1]);\n            for (let i = 0; i < users.length; i++) {\n              let user = users[i];\n              if (user.id === id) {\n                // delete user\n                users.splice(i, 1);\n                localStorage.setItem('users', JSON.stringify(users));\n                break;\n              }\n            }\n\n            // respond 200 OK\n            resolve({\n              ok: true,\n              text: () => Promise.resolve()\n            });\n          } else {\n            // return 401 not authorised if token is null or invalid\n            reject('Unauthorised');\n          }\n          return;\n        }\n\n        // pass through any requests not handled above\n        realFetch(url, opts).then(response => resolve(response));\n      }, 500);\n    });\n  };\n}","map":{"version":3,"names":["users","JSON","parse","localStorage","getItem","configureFakeBackend","realFetch","window","fetch","url","opts","Promise","resolve","reject","setTimeout","endsWith","method","params","body","filteredUsers","filter","user","username","password","length","responseJson","id","firstName","lastName","token","ok","text","stringify","headers","Authorization","match","urlParts","split","parseInt","matchedUsers","newUser","duplicateUser","Math","max","map","push","setItem","i","splice","then","response"],"sources":["/home/rahulbaghel/Downloads/Demo-Project/client/src/_helpers/fake-backend.js"],"sourcesContent":["// array in local storage for registered users\nlet users = JSON.parse(localStorage.getItem('users')) || [];\n    \nexport function configureFakeBackend() {\n    let realFetch = window.fetch;\n    window.fetch = function (url, opts) {\n        return new Promise((resolve, reject) => {\n            // wrap in timeout to simulate server api call\n            setTimeout(() => {\n\n                // authenticate\n                if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n                    // get parameters from post request\n                    let params = JSON.parse(opts.body);\n\n                    // find if any user matches login credentials\n                    let filteredUsers = users.filter(user => {\n                        return user.username === params.username && user.password === params.password;\n                    });\n\n                    if (filteredUsers.length) {\n                        // if login details are valid return user details and fake jwt token\n                        let user = filteredUsers[0];\n                        let responseJson = {\n                            id: user.id,\n                            username: user.username,\n                            firstName: user.firstName,\n                            lastName: user.lastName,\n                            token: 'fake-jwt-token'\n                        };\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(responseJson)) });\n                    } else {\n                        // else return error\n                        reject('Username or password is incorrect');\n                    }\n\n                    return;\n                }\n\n                // get users\n                if (url.endsWith('/users') && opts.method === 'GET') {\n                    // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(users))});\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // get user by id\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        // find user by id in users array\n                        let urlParts = url.split('/');\n                        let id = parseInt(urlParts[urlParts.length - 1]);\n                        let matchedUsers = users.filter(user => { return user.id === id; });\n                        let user = matchedUsers.length ? matchedUsers[0] : null;\n\n                        // respond 200 OK with user\n                        resolve({ ok: true, text: () => JSON.stringify(user)});\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // register user\n                if (url.endsWith('/users/register') && opts.method === 'POST') {\n                    // get new user object from post body\n                    let newUser = JSON.parse(opts.body);\n\n                    // validation\n                    let duplicateUser = users.filter(user => { return user.username === newUser.username; }).length;\n                    if (duplicateUser) {\n                        reject('Username \"' + newUser.username + '\" is already taken');\n                        return;\n                    }\n\n                    // save new user\n                    newUser.id = users.length ? Math.max(...users.map(user => user.id)) + 1 : 1;\n                    users.push(newUser);\n                    localStorage.setItem('users', JSON.stringify(users));\n\n                    // respond 200 OK\n                    resolve({ ok: true, text: () => Promise.resolve() });\n\n                    return;\n                }\n\n                // delete user\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        // find user by id in users array\n                        let urlParts = url.split('/');\n                        let id = parseInt(urlParts[urlParts.length - 1]);\n                        for (let i = 0; i < users.length; i++) {\n                            let user = users[i];\n                            if (user.id === id) {\n                                // delete user\n                                users.splice(i, 1);\n                                localStorage.setItem('users', JSON.stringify(users));\n                                break;\n                            }\n                        }\n\n                        // respond 200 OK\n                        resolve({ ok: true, text: () => Promise.resolve() });\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // pass through any requests not handled above\n                realFetch(url, opts).then(response => resolve(response));\n\n            }, 500);\n        });\n    }\n}"],"mappings":"AAAA;AACA,IAAIA,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE;AAE3D,OAAO,SAASC,oBAAoB,GAAG;EACnC,IAAIC,SAAS,GAAGC,MAAM,CAACC,KAAK;EAC5BD,MAAM,CAACC,KAAK,GAAG,UAAUC,GAAG,EAAEC,IAAI,EAAE;IAChC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpC;MACAC,UAAU,CAAC,MAAM;QAEb;QACA,IAAIL,GAAG,CAACM,QAAQ,CAAC,qBAAqB,CAAC,IAAIL,IAAI,CAACM,MAAM,KAAK,MAAM,EAAE;UAC/D;UACA,IAAIC,MAAM,GAAGhB,IAAI,CAACC,KAAK,CAACQ,IAAI,CAACQ,IAAI,CAAC;;UAElC;UACA,IAAIC,aAAa,GAAGnB,KAAK,CAACoB,MAAM,CAACC,IAAI,IAAI;YACrC,OAAOA,IAAI,CAACC,QAAQ,KAAKL,MAAM,CAACK,QAAQ,IAAID,IAAI,CAACE,QAAQ,KAAKN,MAAM,CAACM,QAAQ;UACjF,CAAC,CAAC;UAEF,IAAIJ,aAAa,CAACK,MAAM,EAAE;YACtB;YACA,IAAIH,IAAI,GAAGF,aAAa,CAAC,CAAC,CAAC;YAC3B,IAAIM,YAAY,GAAG;cACfC,EAAE,EAAEL,IAAI,CAACK,EAAE;cACXJ,QAAQ,EAAED,IAAI,CAACC,QAAQ;cACvBK,SAAS,EAAEN,IAAI,CAACM,SAAS;cACzBC,QAAQ,EAAEP,IAAI,CAACO,QAAQ;cACvBC,KAAK,EAAE;YACX,CAAC;YACDjB,OAAO,CAAC;cAAEkB,EAAE,EAAE,IAAI;cAAEC,IAAI,EAAE,MAAMpB,OAAO,CAACC,OAAO,CAACX,IAAI,CAAC+B,SAAS,CAACP,YAAY,CAAC;YAAE,CAAC,CAAC;UACpF,CAAC,MAAM;YACH;YACAZ,MAAM,CAAC,mCAAmC,CAAC;UAC/C;UAEA;QACJ;;QAEA;QACA,IAAIJ,GAAG,CAACM,QAAQ,CAAC,QAAQ,CAAC,IAAIL,IAAI,CAACM,MAAM,KAAK,KAAK,EAAE;UACjD;UACA,IAAIN,IAAI,CAACuB,OAAO,IAAIvB,IAAI,CAACuB,OAAO,CAACC,aAAa,KAAK,uBAAuB,EAAE;YACxEtB,OAAO,CAAC;cAAEkB,EAAE,EAAE,IAAI;cAAEC,IAAI,EAAE,MAAMpB,OAAO,CAACC,OAAO,CAACX,IAAI,CAAC+B,SAAS,CAAChC,KAAK,CAAC;YAAC,CAAC,CAAC;UAC5E,CAAC,MAAM;YACH;YACAa,MAAM,CAAC,cAAc,CAAC;UAC1B;UAEA;QACJ;;QAEA;QACA,IAAIJ,GAAG,CAAC0B,KAAK,CAAC,eAAe,CAAC,IAAIzB,IAAI,CAACM,MAAM,KAAK,KAAK,EAAE;UACrD;UACA,IAAIN,IAAI,CAACuB,OAAO,IAAIvB,IAAI,CAACuB,OAAO,CAACC,aAAa,KAAK,uBAAuB,EAAE;YACxE;YACA,IAAIE,QAAQ,GAAG3B,GAAG,CAAC4B,KAAK,CAAC,GAAG,CAAC;YAC7B,IAAIX,EAAE,GAAGY,QAAQ,CAACF,QAAQ,CAACA,QAAQ,CAACZ,MAAM,GAAG,CAAC,CAAC,CAAC;YAChD,IAAIe,YAAY,GAAGvC,KAAK,CAACoB,MAAM,CAACC,IAAI,IAAI;cAAE,OAAOA,IAAI,CAACK,EAAE,KAAKA,EAAE;YAAE,CAAC,CAAC;YACnE,IAAIL,IAAI,GAAGkB,YAAY,CAACf,MAAM,GAAGe,YAAY,CAAC,CAAC,CAAC,GAAG,IAAI;;YAEvD;YACA3B,OAAO,CAAC;cAAEkB,EAAE,EAAE,IAAI;cAAEC,IAAI,EAAE,MAAM9B,IAAI,CAAC+B,SAAS,CAACX,IAAI;YAAC,CAAC,CAAC;UAC1D,CAAC,MAAM;YACH;YACAR,MAAM,CAAC,cAAc,CAAC;UAC1B;UAEA;QACJ;;QAEA;QACA,IAAIJ,GAAG,CAACM,QAAQ,CAAC,iBAAiB,CAAC,IAAIL,IAAI,CAACM,MAAM,KAAK,MAAM,EAAE;UAC3D;UACA,IAAIwB,OAAO,GAAGvC,IAAI,CAACC,KAAK,CAACQ,IAAI,CAACQ,IAAI,CAAC;;UAEnC;UACA,IAAIuB,aAAa,GAAGzC,KAAK,CAACoB,MAAM,CAACC,IAAI,IAAI;YAAE,OAAOA,IAAI,CAACC,QAAQ,KAAKkB,OAAO,CAAClB,QAAQ;UAAE,CAAC,CAAC,CAACE,MAAM;UAC/F,IAAIiB,aAAa,EAAE;YACf5B,MAAM,CAAC,YAAY,GAAG2B,OAAO,CAAClB,QAAQ,GAAG,oBAAoB,CAAC;YAC9D;UACJ;;UAEA;UACAkB,OAAO,CAACd,EAAE,GAAG1B,KAAK,CAACwB,MAAM,GAAGkB,IAAI,CAACC,GAAG,CAAC,GAAG3C,KAAK,CAAC4C,GAAG,CAACvB,IAAI,IAAIA,IAAI,CAACK,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC;UAC3E1B,KAAK,CAAC6C,IAAI,CAACL,OAAO,CAAC;UACnBrC,YAAY,CAAC2C,OAAO,CAAC,OAAO,EAAE7C,IAAI,CAAC+B,SAAS,CAAChC,KAAK,CAAC,CAAC;;UAEpD;UACAY,OAAO,CAAC;YAAEkB,EAAE,EAAE,IAAI;YAAEC,IAAI,EAAE,MAAMpB,OAAO,CAACC,OAAO;UAAG,CAAC,CAAC;UAEpD;QACJ;;QAEA;QACA,IAAIH,GAAG,CAAC0B,KAAK,CAAC,eAAe,CAAC,IAAIzB,IAAI,CAACM,MAAM,KAAK,QAAQ,EAAE;UACxD;UACA,IAAIN,IAAI,CAACuB,OAAO,IAAIvB,IAAI,CAACuB,OAAO,CAACC,aAAa,KAAK,uBAAuB,EAAE;YACxE;YACA,IAAIE,QAAQ,GAAG3B,GAAG,CAAC4B,KAAK,CAAC,GAAG,CAAC;YAC7B,IAAIX,EAAE,GAAGY,QAAQ,CAACF,QAAQ,CAACA,QAAQ,CAACZ,MAAM,GAAG,CAAC,CAAC,CAAC;YAChD,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/C,KAAK,CAACwB,MAAM,EAAEuB,CAAC,EAAE,EAAE;cACnC,IAAI1B,IAAI,GAAGrB,KAAK,CAAC+C,CAAC,CAAC;cACnB,IAAI1B,IAAI,CAACK,EAAE,KAAKA,EAAE,EAAE;gBAChB;gBACA1B,KAAK,CAACgD,MAAM,CAACD,CAAC,EAAE,CAAC,CAAC;gBAClB5C,YAAY,CAAC2C,OAAO,CAAC,OAAO,EAAE7C,IAAI,CAAC+B,SAAS,CAAChC,KAAK,CAAC,CAAC;gBACpD;cACJ;YACJ;;YAEA;YACAY,OAAO,CAAC;cAAEkB,EAAE,EAAE,IAAI;cAAEC,IAAI,EAAE,MAAMpB,OAAO,CAACC,OAAO;YAAG,CAAC,CAAC;UACxD,CAAC,MAAM;YACH;YACAC,MAAM,CAAC,cAAc,CAAC;UAC1B;UAEA;QACJ;;QAEA;QACAP,SAAS,CAACG,GAAG,EAAEC,IAAI,CAAC,CAACuC,IAAI,CAACC,QAAQ,IAAItC,OAAO,CAACsC,QAAQ,CAAC,CAAC;MAE5D,CAAC,EAAE,GAAG,CAAC;IACX,CAAC,CAAC;EACN,CAAC;AACL"},"metadata":{},"sourceType":"module"}